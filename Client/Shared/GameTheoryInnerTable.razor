@using System.Text.Json
@using MudBlazor.Utilities
@inject ClipboardService Clipboard
<div>
@if (TableData.IsEmpty)
{
    <MudText>table is kil</MudText>
}
else
{
    <MudStack AlignItems="AlignItems.Center">
        <MudText Typo="Typo.h6">Enemy Options</MudText>
        <MudStack AlignItems="AlignItems.Center" Row>
            <MudText Typo="Typo.h6">Your Options</MudText>
            <div>
                <table>
                <tr>
                    @if (TableData.Editable)
                    {
                        <th><MudTextField @bind-Value="TableData.Name" Placeholder="Enter Table Name" /></th>
                    }
                    else
                    {
                        <th><MudText>@TableData.Name</MudText></th>
                    }
                    @foreach ((int index, _) in TableData.TopHeaders.Index())
                    {
                        if (TableData.Editable)
                        {
                            <th><MudTextField @bind-Value="@TableData.TopHeaders[index]" Placeholder="Enter Move Name"/></th>
                        }
                        else
                        {
                            <th><MudText>@TableData.TopHeaders[index]</MudText></th>
                        }
                    }
                    <th rowspan="2"><MudText>Expected Value</MudText></th>
                </tr>
                <tr>
                    <td><MudText>Probability Weights</MudText></td>
                    @foreach ((int i, _) in TableData.ProbabilitiesRow.Values.Index())
                    {
                        <td>
                            <MudStack AlignItems="AlignItems.Center" Row>
                                <MudNumericField Min="0" @bind-Value="@TableData.ProbabilitiesRow.Values[i]" Style="max-width: 100px"/>
                                <MudText>(@(float.Round(TableData.ProbabilitiesRow.Values[i] / (float)TableData.ProbabilitiesRow.Values.Sum() * 100))%)</MudText>
                            </MudStack>
                        </td>
                    }
                </tr>
                @foreach (GameTheoryRow row in DataRows)
                {
                    <tr>
                        @if (TableData.Editable)
                        {
                            <td><MudTextField @bind-Value="@TableData.SideHeaders[row.Index]" Placeholder="Enter Move Name"/></td>
                        }
                        else
                        {
                            <td><MudText>@TableData.SideHeaders[row.Index]</MudText></td>
                        }
                        @foreach ((int i, _) in row.Values.Index())
                        {
                            if (TableData.Editable)
                            {
                                <td><MudNumericField @bind-Value="@row.Values[i]" HideSpinButtons/></td>
                            }
                            else
                            {
                                <td><MudText Class="@DamageValueColor(row.Values[i])">@row.Values[i]</MudText></td>
                            }
                        }
                        <td><MudText Class="@DamageValueColor((int)row.ExpectedValue)">@float.Round(row.ExpectedValue)</MudText></td>
                    </tr>
                }
            </table>
            </div>
        </MudStack>
        @if (!DisableControls)
        {
            <MudStack AlignItems="AlignItems.Center" Justify="Justify.FlexEnd" Row>
                @if (!TableData.ReadOnly)
                {
                    <MudButton OnClick="OnClickClear">Clear Table</MudButton>
                    <MudSwitch Label="Edit Mode" @bind-Value="TableData.Editable"/>
                }
                <MudButton OnClick="OnClickCopy">Copy To Clipboard</MudButton>
            </MudStack>
        }
    </MudStack>
}
</div>
<style>
    div:has(> table) {
        border-width: 1px;
        border-style: solid;
        border-radius: 4px;
        border-color: #505050;
    }
    table {
        font-size: x-large;
        border-collapse: collapse;
        .mud-input-adornment-text {
            font-size: large;
            text-align: center;
        }
        .mud-input {
            font-size: large;
        }
        input {
            text-align: center;
        }
    }
    th, td {
        text-align: center;
        border-width: 2px;
        border-style: solid;
        border-radius: 4px;
        border-color: #505050;
        padding: 8px;
    }
    tr:nth-child(1) {
        background-color: #2c2c2f;
    }
    td:nth-child(1) {
        background-color: #2c2c2f;
    }
    tr:nth-child(2n) {
        background-color: #2D2E37;
    }
    tr:nth-child(2n+3) {
        background-color: #32333D;
    }
    .negative-value {
        color: palevioletred;
    }
    .zero-value {
        color: lightgoldenrodyellow;
    }
    .positive-value {
        color: darkseagreen;
    }
</style>

@code {

    [Parameter]
    public required GameTheoryTableData TableData { get; set; }

    [Parameter]
    public required EventCallback<GameTheoryTableData> TableDataChanged { get; set; }

    [Parameter] public bool DisableControls { get; set; }
    [Parameter] public bool ReadOnly { get; set; }

    private IEnumerable<GameTheoryRow> DataRows
    {
        get
        {
            if (TableData.Editable)
            {
                return TableData.DataRows;
            }
            return TableData.DataRows.OrderByDescending(dr => dr.ExpectedValue);
        }
    }

    private bool _isImportVisible;

    private string SerializedTableData
    {
        get => JsonSerializer.Serialize(TableData);
        set => TableData = JsonSerializer.Deserialize<GameTheoryTableData>(value);
    }
    
    private void OnClickClear()
    {
        TableData.Editable = true;
        TableData.Clear();
    }
    
    private async Task OnClickCopy()
    {
        await Clipboard.WriteTextAsync(SerializedTableData);
    }

    private static string DamageValueColor(int value)
    {
        return new CssBuilder()
              .AddClass("negative-value", value < 0)
              .AddClass("zero-value", value == 0)
              .AddClass("positive-value", value > 0)
              .Build();
    }
}
